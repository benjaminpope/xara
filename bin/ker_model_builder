#!/usr/bin/env python

#import discretizor_gui
from PyQt4 import QtCore, QtGui, uic
import pyqtgraph as pg
import sys
import numpy as np

from xaosim import pupil
import xara

sz = 2000

class MyWindow(QtGui.QMainWindow):
    def __init__(self):
        super(MyWindow, self).__init__()
        try:
            uic.loadUi('config/discretizor.ui', self)
        except:
            uifile = xara.__path__[0]+'/../config/discretizor.ui'
            uic.loadUi(uifile, self)
            
        self.pw = self.graphicsView
        self.imv = pg.ImageItem()
        self.pw.addItem(self.imv)
        self.data = np.zeros((sz,sz))
        self.imv.setImage(self.data)

        # read startup values for parameters
        self.apdiam = self.Apdiam_doubleSpinBox.value()
        self.obdiam = self.Obdiam_doubleSpinBox.value()
        self.beta   = self.Beta_doubleSpinBox.value()
        self.thick  = self.Thick_doubleSpinBox.value()
        self.offset = self.Offset_doubleSpinBox.value()
        self.ifudge = self.innerf_doubleSpinBox.value()

        self.exquad = 0
        self.asym_arm_thick = self.dSpinB_asym_arm_thick.value()
        self.asym_arm_PA = self.dSpinB_asym_arm_PA.value()

        # init the graph with default parameters
        self.update_pupil()
        self.update_model_and_plot()

        self.fname = "telescope_discrete_model.txt" # default file name
        
        # ======================================================
        # connect the signals generated by widgets to functions
        # ======================================================
        
        self.pushButt_save.clicked.connect(self.save)
        self.actionSaveAs.triggered.connect(self.save_as)
        self.actionSaveAs.setShortcut('Ctrl+S')
        
        self.actionQuit.triggered.connect(sys.exit)
        self.actionQuit.setShortcut('Ctrl+Q')
        
        self.pushButt_compute.clicked.connect(self.update_model_and_plot)

        boxes = ["Apdiam_doubleSpinBox",
                 "Obdiam_doubleSpinBox",
                 "Beta_doubleSpinBox",
                 "Thick_doubleSpinBox",
                 "Offset_doubleSpinBox"]

        for i, box in enumerate(boxes):
            signal = 'self.%s.valueChanged[float]' % (box,)
            exec '%s.connect(self.update_pupil_and_plot)' % (signal,)

        # ---------------------------------
        self.check_asym_quad.stateChanged[int].connect(
            self.update_pupil_and_plot)

        self.spinB_asym_quad.valueChanged[int].connect(
            self.update_exquad)

        self.check_asym_arm.stateChanged[int].connect(
            self.update_pupil_and_plot)

        self.dSpinB_asym_arm_thick.valueChanged[float].connect(
            self.update_asym_arm_thick)
        
        self.dSpinB_asym_arm_PA.valueChanged[float].connect(
            self.update_asym_arm_PA)

        # ---------------------------------
        boxes = ["step_doubleSpinBox",
                 "ang1_doubleSpinBox",
                 "ang2_doubleSpinBox",
                 "innerf_doubleSpinBox"]

        for i, box in enumerate(boxes):
            signal = 'self.%s.valueChanged[float]' % (box,)
            exec '%s.connect(self.update_model_and_plot)' % (signal,)

        self.show()

    # ==========================================================
    def update_exquad(self):
        self.exquad = self.spinB_asym_quad.value() - 1
        if (self.check_asym_quad.checkState()):
            self.update_pupil_and_plot()

    def update_asym_arm_thick(self):
        self.asym_arm_thick = self.dSpinB_asym_arm_thick.value()
        if (self.check_asym_arm.checkState()):
            self.update_pupil_and_plot()
            
    def update_asym_arm_PA(self):
        self.asym_arm_PA = self.dSpinB_asym_arm_PA.value()
        if (self.check_asym_arm.checkState()):
            self.update_pupil_and_plot()
            
    # ==========================================================
    def update_asym_thick(self):
        self.asym_thick = self.dspinB_asym_arm_thick.value()
        if (self.check_asym_quad.checkState()):
            self.update_pupil_and_plot()

    # ==========================================================
    def update_pupil(self):
        self.apdiam = self.Apdiam_doubleSpinBox.value()
        self.obdiam = self.Obdiam_doubleSpinBox.value()
        self.beta   = self.Beta_doubleSpinBox.value()
        self.thick  = self.Thick_doubleSpinBox.value()
        self.offset = self.Offset_doubleSpinBox.value()
        keep_spiders = True
        split = True
        if self.thick < 0.01:
            keep_spiders = False
            split = False
        self.quads = pupil.four_spider_mask((sz,sz), sz/2, self.apdiam,
                                            self.obdiam, self.beta,
                                            self.thick, self.offset,
                                            spiders=keep_spiders, split=split)

        if (self.check_asym_quad.checkState() == 2):
            if split:
                self.data = np.delete(self.quads, self.exquad, 0).sum(axis=0)
        else:
            if split:
                self.data = self.quads.sum(axis=0)
            else:
                self.data = self.quads.copy()

        if self.check_asym_arm.checkState():
            self.aarm = pupil.radial_arm((sz,sz), sz/2, self.asym_arm_PA,
                                         self.asym_arm_thick ).astype('bool')
            self.data *= self.aarm
            
    # ==========================================================
    def compute_model(self):
        dtor = np.pi / 180.0
        self.plot_pupil()

        self.th1    = self.ang1_doubleSpinBox.value()
        self.th2    = self.ang2_doubleSpinBox.value()
        self.ifudge = self.innerf_doubleSpinBox.value()
        
        srad = self.step_doubleSpinBox.value()
        nr   = 1.5 * np.round(self.apdiam/(2*srad)).astype(int) # number of "rings"
        
        th1    = self.th1  * dtor
        th2    = self.th2  * dtor
        beta   = self.beta * dtor
        ix, iy = np.meshgrid(np.arange(2*nr)-nr, np.arange(2*nr)-nr)
        ix     = ix.flatten()
        iy     = iy.flatten()

        self.xc = srad * (ix * np.cos(th1) + iy * np.cos(th2))
        self.yc = srad * (ix * np.sin(th1) + iy * np.sin(th2))

        xx, yy = self.xc.copy(), self.yc.copy()       # temporary copies

        # Apply pupil geometry constraints
        rmin = self.obdiam/2.0
        rmax = self.apdiam/2.0
        dist = np.sqrt(xx**2 + yy**2)
        if rmin < 1e-2:
            keep = (dist < rmax - self.ifudge)
        else:
            keep = (rmin + self.ifudge < dist) * (dist < rmax - self.ifudge)

        self.xc = xx[keep]
        self.yc = yy[keep]

        if self.thick > 1e-2:
            thick0 = self.thick + 2 * self.ifudge
            x0  = thick0 / (4 * np.sin(beta)) + 0.5 * self.offset
            y0  = thick0 / (4 * np.cos(beta)) - 0.5 * self.offset * np.tan(beta)

            xx, yy = self.xc.copy(), self.yc.copy()       # temporary copies
            keep1 = (xx >=  x0) * (np.abs(np.arctan(yy/(xx-x0+1e-8))) < beta)
            keep2 = (xx <= -x0) * (np.abs(np.arctan(yy/(xx+x0+1e-8))) < beta)
            keep3 = (yy >= 0.0) * (np.abs(np.arctan((yy-y0)/(xx+1e-8))) > beta)
            keep4 = (yy <= 0.0) * (np.abs(np.arctan((yy+y0)/(xx+1e-8))) > beta)

            nothing = np.isnan(xx)
        
            if self.check_asym_quad.checkState():
                quads = "nothing"
                for ii in xrange(4):
                    if ii != self.exquad:
                        quads += " + keep%d" % (ii+1,)
                    exec 'self.xc = xx[%s]' % (quads,)
                    exec 'self.yc = yy[%s]' % (quads,)
            else:
                self.xc = xx[keep1 + keep2 + keep3 + keep4]
                self.yc = yy[keep1 + keep2 + keep3 + keep4]

        if self.check_asym_arm.checkState():
            tha = self.asym_arm_PA*dtor
            xrot = self.xc * np.cos(tha) - self.yc * np.sin(tha)
            yrot = self.xc * np.sin(tha) + self.yc * np.cos(tha)
            ymax = self.asym_arm_thick * self.apdiam/2.0 + self.ifudge
            throw = (xrot > 0) * (np.abs(yrot) <= ymax)
            keep = True - throw
            self.xc = self.xc[keep]
            self.yc = self.yc[keep]

        self.tc = np.ones(self.xc.size)
        
    # ==========================================================
    def plot_pupil(self):
        self.pw.clear()
        self.imv.setImage(1.0 * self.data.transpose())
        self.pw.addItem(self.imv)

    # ==========================================================
    def plot_model(self):
        self.xp = self.xc * sz / self.apdiam + sz/2
        self.yp = self.yc * sz / self.apdiam + sz/2
        self.pw.plot(self.xp, self.yp, pen=None, symbolSize=5,
                     symbolBrush=(255,0,0), symbolPen='w')

    # ==========================================================
    def update_pupil_and_plot(self):
        self.update_pupil()
        self.plot_pupil()
        self.plot_model()

    # ==========================================================
    def update_model_and_plot(self):
        self.compute_model()
        self.plot_pupil()
        self.plot_model()

    def save_as(self):
        self.fname = str(
            QtGui.QFileDialog.getSaveFileName(self,'Save as', './'))
        print("%s : %d coord. points" % (
            self.fname.split('/')[-1], self.xc.size))
        np.savetxt(self.fname,
                   np.transpose((self.xc, self.yc, self.tc)), fmt='%12.9f')

    def save(self):
        print("%s : %d coord. points" % (self.fname.split('/')[-1], self.xc.size))
        np.savetxt(self.fname, np.transpose((self.xc, self.yc, self.tc)),
                   fmt='%12.9f')

# ==========================================================
# ==========================================================
def main():
    app = QtGui.QApplication(sys.argv)
    gui = MyWindow()
    sys.exit(app.exec_())
    
if __name__ == "__main__":
    main()
    
